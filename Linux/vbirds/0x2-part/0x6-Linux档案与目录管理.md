# Linux文件与目录管理

## 1、目录与路径

绝对/相对路径的写法并不相同，需要特别注意。此外，当你下达指令时，该指令时透过什么工鞥来取得的？这与PATH这个变数有关。下面来学习喽！  

### 1.1、相对路径与绝对路径

在开始学习切换目录之前，必须要先了解一下所谓的【路径(PATH)】，又去的是：什么是【相对路径】于【绝对路径】，再次强调一下。  

- **绝对路径**：路径的写法【一定由根目录/写起】，例如：/usr/hare/这个目录。  
- **相对路径**：路径的写法【不是由/写起】，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成：【cd ../man】这就是相对路径的写法！相对路径意指【相对于目前工作目录的路径】！  

-----

- 相对路径的用途  

那么相对路径与绝对路径由什么了不起呀？真了不起呢！假设你需要装一个软件，这个软件共需要三个目录，分别是 etc, bin, man 这三个目录，然而由于不同的人喜欢安装在不同的目录之下，假设安装的路径是 /usr/local/packages/etc, /usr/local/packages/bin以及/usr/local/packages/man,不过乙却喜欢安装在 /home/packages/etc, /home/packages/bin, /home/packages/man这三个目录中，请问如果需要用到绝对路径的话，那是否很麻烦呢？是的！如此一来每个目录下的东西就很难对应的起来！这个时候相对路径的写法就显得特别重要了！  

此外，如果你跟鸟哥一样，喜欢将路径的名字写的很长，好让自己知道那个目录是在干什么的，那么用相对路径会很方便的。  


- 绝对路径用途  

但是对于档名的正确性来说，【绝对路径的正确度要比较好】。一般来说，鸟哥建议，如果在写程序（shell scripts）来管理系统的条件下，务必使用绝对路径的写法。怎么说呢？因为绝对路径的写法虽然比较麻烦，但是可以肯定这个写法绝对不会有问题。如果使用相对路径在程序当中，则可能由于你执行的工作环境不同，导致一些问题的发生。这个问题在工作排程（at， cron，第十五章）当中尤其重要！  

### 1.2、目录的相关操作

我们之前提到过cd命令，那目录还可以进行哪些指令呢？例如：建立目录，删除目录，之类的，还有，得要先知道，就是有哪些比较特殊的目录？一下这些得特别记住：  

```
.         代表此層目錄
..        代表上一層目錄
-         代表前一個工作目錄
~         代表『目前使用者身份』所在的家目錄
~account  代表 account 這個使用者的家目錄(account是個帳號名稱)
```

**需要注意的是**：在所有目录底下都会存在的两个目录，分别是【.】和【..】分别代表此层与上层目录的意思。  

**根目录的上一层与根目录自己是同一个目录**。  

了解一下几个常见的处理目录的指令吧：  

- cd ： 变换目录  
- pwd ： 显示目前的目录  
- mkdir ： 建立一个新的目录  
- rmdir ： 删除一个空的目录  

-----

- cd（change directory，改变目录）  

我们知道 dmtsai 这个使用者的家目录是 /home/dmtsai/,而 root 家目录则是 /root/,假设我们以 root身份在linux系统中，那么简单的说明一下这几个特殊的目录的意义是：  

```
[dmtsai@study ~]$ su -  # 先切換身份成為 root 看看！
[root@study ~]# cd [相對路徑或絕對路徑]
# 最重要的就是目錄的絕對路徑與相對路徑，還有一些特殊目錄的符號囉！
[root@study ~]# cd ~dmtsai
# 代表去到 dmtsai 這個使用者的家目錄，亦即 /home/dmtsai
[root@study dmtsai]# cd ~
# 表示回到自己的家目錄，亦即是 /root 這個目錄
[root@study ~]# cd
# 沒有加上任何路徑，也還是代表回到自己家目錄的意思喔！
[root@study ~]# cd ..
# 表示去到目前的上層目錄，亦即是 /root 的上層目錄的意思；
[root@study /]# cd -
# 表示回到剛剛的那個目錄，也就是 /root 囉～
[root@study ~]# cd /var/spool/mail
# 這個就是絕對路徑的寫法！直接指定要去的完整路徑名稱！
[root@study mail]# cd ../postfix
# 這個是相對路徑的寫法，我們由/var/spool/mail 去到/var/spool/postfix 就這樣寫！
```

cd 是Change directory的缩写，这个用来变换工作目录的指令，注意，目录名称与cd指令之间存在一个空格。  
登入linux后，每个账号都会在自己账号的家目录中，那回到上一层目录可以用【cd ..】，利用相对路径的写法必须要确认你目前的路径才能正确的渠道想要的目录。  
其实，我们的提示符即【root@study ~】#当中，就已经有指出目前的目录了，刚登入时会在自己的家目录，而家目录还有一个代码，那就是【~】符号！  
使用【cd ~】可以回到家目录，如果只输入cd那代表的就是回到自己家的意思。  
【cd -】代表着回到上一次所在的工作目录。  

- linux一般都会预设指令列模式（bash shell）具有档案不起功能，常常需要按【tab】键来补齐目录完整，这可是一个好习惯，可以很好的避免打错字。  

-----

- pwd（显示目前所在的目录）  

```
[root@study ~]# pwd [-P]
選項與參數：
-P  ：顯示出確實的路徑，而非使用連結 (link) 路徑。

範例：單純顯示出目前的工作目錄：
[root@study ~]# pwd
/root   <== 顯示出目錄啦～

範例：顯示出實際的工作目錄，而非連結檔本身的目錄名而已
[root@study ~]# cd /var/mail   <==注意，/var/mail是一個連結檔
[root@study mail]# pwd
/var/mail         <==列出目前的工作目錄
[root@study mail]# pwd -P
/var/spool/mail   <==怎麼回事？有沒有加 -P 差很多～
[root@study mail]# ls -ld /var/mail
lrwxrwxrwx. 1 root root 10 May  4 17:51 /var/mail -> spool/mail
# 看到這裡應該知道為啥了吧？因為 /var/mail 是連結檔，連結到 /var/spool/mail
# 所以，加上 pwd -P 的選項後，會不以連結檔的資料顯示，而是顯示正確的完整路徑啊！
```

pwd是print working directory的缩写，也就是显示目前所在的目录的指令。  
因为很多的套件所使用的目录名称都相同，例如 /usr/local/etc和/etc,这两个，在普通linux仅列出最后面一个目录而已，这个时候可能就需要用到pwd来看看自己到底在哪个目录了，以免搞混了。  

- 还有个【-P】的选项，它可以让我们取得正确的目录名称，而不是以链接档的路径来显示的。  


-----

- mkdir（建立新目录）  

```
[root@study ~]# mkdir [-mp] 目錄名稱
選項與參數：
-m ：設定檔案的權限喔！直接設定，不需要看預設權限 (umask) 的臉色～
-p ：幫助你直接將所需要的目錄(包含上層目錄)遞迴建立起來！

範例：請到/tmp底下嘗試建立數個新目錄看看：
[root@study ~]# cd /tmp
[root@study tmp]# mkdir test    <==建立一名為 test 的新目錄
[root@study tmp]# mkdir test1/test2/test3/test4
mkdir: cannot create directory ‘test1/test2/test3/test4’: No such file or directory
# 話說，系統告訴我們，沒可能建立這個目錄啊！就是沒有目錄才要建立的！見鬼嘛？
[root@study tmp]# mkdir -p test1/test2/test3/test4
# 原來是要建 test4 上層沒先建 test3 之故！加了這個 -p 的選項，可以自行幫你建立多層目錄！

範例：建立權限為rwx--x--x的目錄
[root@study tmp]# mkdir -m 711 test2
[root@study tmp]# ls -ld test*
drwxr-xr-x. 2 root   root  6 Jun  4 19:03 test
drwxr-xr-x. 3 root   root 18 Jun  4 19:04 test1
drwx--x--x. 2 root   root  6 Jun  4 19:05 test2
# 仔細看上面的權限部分，如果沒有加上 -m 來強制設定屬性，系統會使用預設屬性。
# 那麼你的預設屬性為何？這要透過底下介紹的 umask 才能瞭解喔！ ^_^
```

如果想要建立新的目录的化，那么就使用mkdir（make directory）吧！不过，在预设的情况下，你需要的目录得一层一层的建立才行！  
不过，现在有个更简单有效的方法！那就是加上`-p`这个选项哦！这个会递归穿件，并且，如果该目录本来就已经存在时，系统也不会显示错误信息哦！（不过鸟哥不建议使用-p因为如果打错字，目录就会乱七八糟的。  
另外，还有个地方必须要现有概念，那就是【预设权限】的地方。我们可以利用 -m 来强制给予一个新的目录相关的权限，例如上表当中，我们给予了 -m 711来给予新的目录 drwx--x--x 的权限。不过，如果没有给予 -m 选项时，那么预设的新建目录权限又是什么呢？这个和umask有关，我们在本章后头会介绍的。  

--------

- rmdir(删除【空】的目录)  

```
[root@study ~]# rmdir [-p] 目錄名稱
選項與參數：
-p ：連同『上層』『空的』目錄也一起刪除

範例：將於mkdir範例中建立的目錄(/tmp底下)刪除掉！
[root@study tmp]# ls -ld test*   <==看看有多少目錄存在？
drwxr-xr-x. 2 root   root  6 Jun  4 19:03 test
drwxr-xr-x. 3 root   root 18 Jun  4 19:04 test1
drwx--x--x. 2 root   root  6 Jun  4 19:05 test2
[root@study tmp]# rmdir test   <==可直接刪除掉，沒問題
[root@study tmp]# rmdir test1  <==因為尚有內容，所以無法刪除！
rmdir: failed to remove ‘test1’: Directory not empty
[root@study tmp]# rmdir -p test1/test2/test3/test4
[root@study tmp]# ls -ld test*    <==您看看，底下的輸出中test與test1不見了！
drwx--x--x. 2 root   root  6 Jun  4 19:05 test2
# 瞧！利用 -p 這個選項，立刻就可以將 test1/test2/test3/test4 一次刪除～
# 不過要注意的是，這個 rmdir 僅能『刪除空的目錄』喔！
```

如果有想要深处的目录，就使用 rmdir 吧！  
注意，目录需要一层一层的产出才行！而且被删除的目录里面必定不能存在其他的目录或档案！这意识所谓的空目录（empty directory)的意思啊！  
如果要将所有目录下的东西都删除掉！这个时候就必须要使用【rm -r】来进行递归删除了，不过还是使用rmdir比较不危险，也可以尝试使用 -p 的选项加入，来删除上层的目录哦！

### 1.3、关于执行文件路径的变量：$PATH

经过前面FHS的学习，我们可以知道查阅档案属性的指令ls完整大难名为： /bin/ls（这是绝对路径），那为什么我可以在任何地方执行 /bin/ls 这个指令呢？  
为什么我在任何目录下输入 ls 就一定可以显示出一些信息而不会说找不到该 /bin/ls 指令呢？  
这是因为环境变量 PATH 的帮助所致。  

**当我们在执行一个指令的时候，例如 ls这个命令，系统会依照PATH的设定去每个PATH定义的目录下搜寻档名为 ls 的可执行文档，如果PATH定义的目录中含有多个档名为ls的可执行档，那么先搜索到的同名指令先被执行。**  

现在，可以下达【echo $PATH】来看看到底有那些目录被定义出来了？ echo有【显示、打印】的意思，而PATH前面加的 $ 表示后面节的是变数，所以会显示出目前的PATH  

```
範例：先用root的身份列出搜尋的路徑為何？
[root@study ~]# echo $PATH
/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin

範例：用dmtsai的身份列出搜尋的路徑為何？
[root@study ~]# exit    # 由之前的 su - 離開，變回原本的帳號！或再取得一個終端機皆可！
[dmtsai@study ~]$ echo $PATH
/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin
# 記不記得我們前一章說過，目前 /bin 是連結到 /usr/bin 當中的喔！
```

PATH 一定是大写，这个变数的内容是由一堆目录所组成的，每个目录中间用冒号(:)来间隔，每个目录是有【顺序】之分的。仔细看以下上面的输出，你可以发现但无论是 root 还是 hare 都有 /bin 或 /usr/bin 这个目录在PATH变数内，所以当然能够在任何地方执行ls来找到 /bin/ls 执行档喽，因为 /bin 在centOS 7 当中，就是链接到 /usr/bin 去的，所以这两个目录内容会一模一样。  

- 假设用root将ls由/bin/ls移动称为/root/ls  
    - 1. 输入ls是否还可以执行。  
    - 2. 若不能，该如何执行ls这个指令？  
    - 3. 若要直接输入ls即可执行，又该如何进行？  

1. 将ls移动后，无论在那个目录输入ls都无法执行，也就是不能直接输入ls来执行，因为 /root 这个目录并不在PATH指定的目录中，所以，计时你在 /root 目录下，也不能够搜寻到ls这个指令。  
2. 因为ls的确存在于 /root 底下，并不是被删除了，所以可以通过**绝对路径** 或者**相对路径** 直接指定这个执行档档名，两种方法：1.`/root/ls`2.`./ls`  
3. 如果想要让root在任何目录都可以执行/root地下的ls，那么就将/root加入PATH当中即可。加入方法：  
    - `PATH="${PATH}:/root"`  
另外，除了 $PATH ，如果想要更明确定义出变数的名称，可以使用大括号 ${PATH} 来处理变数的呼叫。  
**注意这个实验做完了需要把ls放回去，不然系统可能会挂的**  

- 如果有两个 ls 指令在不同的目录中，那么下达 ls 的时候，哪个会被执行？  
    - 就是 ${PATH} 里面哪个目录先被查询，则那个目录下的指令就会被先执行了。  

- 为什么 ${PATH} 目录不加入本目录(.)?
    - 如果加入本目录，的确能够在指令所在目录执行指令。但是因为你的工作目录并非国定（常常会cd）因此能够执行的指令会有变动（因为每个目录地下的可执行档案不相同），这对使用者来说并不是好事。  
    - 如果有坏人使用者在 /tmp 地下做了一个指令，因为 /tmp 大家都能写入的环境，所以当然可以这样做。加入该指令可能会窃取使用者的一些资料，如果你还使用root的身份来执行这个指令，是不是很糟糕？如果这个指令的名称又是经常用到的 ls 时，那【中镖】的记录就更高了。  

所以，为了安全起见，并不建议将【.】加入PATH的搜索目录中。  

--------

由上我们可以得知几件事情：  

- 不同身份使用者预设的PATH不同，预设能够随意执行的指令也不同(如root与hare);  
- PATH是可以修改的;
- 使用绝对路径或相对路径直接指定某个指令的档名来执行，会比搜寻PATH来的正确；  
- 指令应该要放置到正确的目录下，执行才会比较方便；  
- 本目录(.)最好不要放到PATH当中。  

## 2、文件与目录管理

了解了路径，在了解一下档案的基本管理。  
档案的基本管理不外乎：属性、拷贝、删除档案 及 移动档案或目录 等等。  

### 2.1、文件与目录的查看：ls

```
[root@study ~]# ls [-aAdfFhilnrRSt] 檔名或目錄名稱..
[root@study ~]# ls [--color={never,auto,always}] 檔名或目錄名稱..
[root@study ~]# ls [--full-time] 檔名或目錄名稱..
選項與參數：
-a  ：全部的檔案，連同隱藏檔( 開頭為 . 的檔案) 一起列出來(常用)
-A  ：全部的檔案，連同隱藏檔，但不包括 . 與 .. 這兩個目錄
-d  ：僅列出目錄本身，而不是列出目錄內的檔案資料(常用)
-f  ：直接列出結果，而不進行排序 (ls 預設會以檔名排序！)
-F  ：根據檔案、目錄等資訊，給予附加資料結構，例如：
      *:代表可執行檔； /:代表目錄； =:代表 socket 檔案； |:代表 FIFO 檔案；
-h  ：將檔案容量以人類較易讀的方式(例如 GB, KB 等等)列出來；
-i  ：列出 inode 號碼，inode 的意義下一章將會介紹；
-l  ：長資料串列出，包含檔案的屬性與權限等等資料；(常用)
-n  ：列出 UID 與 GID 而非使用者與群組的名稱 (UID與GID會在帳號管理提到！)
-r  ：將排序結果反向輸出，例如：原本檔名由小到大，反向則為由大到小；
-R  ：連同子目錄內容一起列出來，等於該目錄下的所有檔案都會顯示出來；
-S  ：以檔案容量大小排序，而不是用檔名排序；
-t  ：依時間排序，而不是用檔名。
--color=never  ：不要依據檔案特性給予顏色顯示；
--color=always ：顯示顏色
--color=auto   ：讓系統自行依據設定來判斷是否給予顏色
--full-time    ：以完整時間模式 (包含年、月、日、時、分) 輸出
--time={atime,ctime} ：輸出 access 時間或改變權限屬性時間 (ctime) 
                       而非內容變更時間 (modification time)
```


### 2.2、复制、删除与移动：cp、rm、mv

### 2.3、获取路径的文件名与目录名称pwd

## 3、文件内容查看

### 3.1、直接查看文件内容

### 3.2、可翻页查看

### 3.3、数据截取

### 3.4、非纯文本文件：od

### 3.5、修改文件时间或创建新文件：touch

## 4、文件与目录的默认权限与隐藏权限

### 4.1、文件默认权限：umask

### 4.2、文件隐藏属性

### 4.3、文件特殊权限：SUID、SGID、SBIT

### 4.4、观察文件类型：file

## 5、命令与文件的查找

### 5.1、脚本文件的查找

### 5.2、文件的查找

## 6、极其重要的复习：权限与命令的关系




