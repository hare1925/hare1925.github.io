# 第四章 程序的控制结构

## 4.1 程序的分支结构
顺序结构
分之结构
循环结构

方法论方面：python程序的控制语法及结构
实践能力：学会编写带有条件判断及循环的程序

### 程序的控制结构
- 单分支结构
- 二分支结构
- 多分支结构
- 条件判断及组合
- 程序的异常处理

分支结构是根据判断结构而选择不同向前路径的运行方式

### 单分支结构

根据判断条件结果而选择不同向前路径的运行方式

```py
if <条件>:
    <语句块>
```

运行为：判断为True运行语句块，False跳出if，继续执行。

### 二分支结构

根据判断条件结果而选择不同向前路径的运行方式

```py
if <条件>:
    <语句块1>
else:
    <语句块2>
```

运行为：判断条件为True执行语句块1，为False执行语句块2.

- 二分支结构的紧凑形式：适用于简单表达式的二分支结构

```py
<表达式1> if <条件> else <表达式2>
```

例如：

```py
guess = eval(input())
print("猜{}了".format("对" if guess == 99 lese "错"))
```

- 需要注意：紧凑形式可以用非常简洁的代码表达二分支结构，但是if else 所对应的输出不是语句，而是表达式。
所谓的表达式是语句的一部分。
简单理解为：语句我们可以理解为带赋值形式的有等号构成的语句。
但是 if else 不是支持这种带等号的赋值形式，它只支持表达式形式，也就是语句中的一部分，比如：字符串 对 或着字符串 错 它只是语句的一部分，它并没有赋值的过程。

### 多分支结构

多分支结构是根据多个条件，来选择不同语句块运行的一种分支结构，它的典型方式是使用保留字： if elif else

```py
if <条件>:
    <语句块1>
else:
    <语句块2>
    ......
else:
    <语句块N>
```

- 错误代码示例：

```py
score = eval(input())
if score >= 60:
    grade = "D"
elif score >= 70:
    grade = "C"
elif score >= 80:
    grade = "B"
elif score >= 90:
    grade = "A"
print("输入成绩属于级别{}".format(grade))
```

以上仔细分析是错误的，所以：
在多分支结构的问题上，一定要注意：

- 注意多条件之间的包含关系
- 注意变量取值范围的覆盖

以上代码，运行是正确的，但是逻辑是错误的，所以最后输出的结构也将会是错误的。

### 条件判断及组合

操作符

| 操作符 | 数学符号 | 描述 |
|:----:|:----:|:----:|
| < | < | 小于 |
| <= | 小于等于号 | 小于等于 |
| >= | 大于等于号 | 大于等于 |
| > | > | 大于 |
| == | = | 等于 |
| ！= | 不等于号 | 不等于 |


用于条件组合的三个保留字

| 操作符及使用 | 描述 |
|:----:|:----:|
| x and y | 两个条件x和y的逻辑与 |
| x or y | 两个条件x和y的逻辑或 |
| not x | 条件x的逻辑非 |

示例：

```py
guess = eval(input())
if guess > 99 or guess < 99:
    print("猜错了")
else:
    print("才对了")
```

```py
if not True:
    print("语句块2")
else:
    print("语句块1")
# 这样的条件语句是永远不会执行语句块2的，只会执行else部分的语句块1
```

### 程序异常处理

例如：

```py
num = eval(input("请输入一个整数："))
print(num**2)
```

以上代码，当用户输入的是 abc 时，程序就会报错。因为用eval去掉abc两侧的引号后就变成了python中的变量，但是这个变量我们并没有定义，所以就会报错喽。

so python提供了异常处理的相关机制：

有两种非常基本的处理方法：

```py
# 把代码放到语句块1的位置，把异常的时候需要执行的放到语句块2
try:
    <语句块1>  # 如果程序没有异常，将会直接输出结果
except <异常类型>： # 这里的 异常类型 是可选项，只有在这种异常出现时，执行相应的语句块2（标注异常类型后，仅响应该异常；异常类型名字等同于变量，是python程序内部定义的）
    <语句块2>  # 如果语句块1出现了异常，就会执行语句块2
```

- 异常处理的高级使用

```py
try:
    <语句块1>
except:
    <语句块2>
else:
    <语句块3>
finally:
    <语句块4>
```

- 首先执行 try 的 语句块1
- 出现异常时执行 execpt 的 语句块2
- 在不发生异常时，奖励性的执行 else 的 语句块3
- 无论发不发生异常，都将执行 finally 的 语句块4


## 4.2 实例5：身体质量只是BMI

BMI:对身体质量的刻画（Body Mass Index）
国际上常用的衡量人体肥胖和健康程度的重要标准，主要用于统计分析
定义： BMI = 体重（kg）/ 身高**2(m**2)

### 关注多分支条件的组合
- 多分支条件之间的覆盖是重要问题
- 程序可运行，但不正确，要注意多分支
- 分支结构是程序的重要框架，读程序先看分支

## 4.3 程序的循环结构

- 遍历循环
- 无限循环
- 循环控制保留字
- 循环的高级用法

### python只提供两种循环
- 遍历循环对应保留字-for
- 无限循环对应保留字-while

### 遍历摸个结构形成的循环运行方式
for <循环变量> in <遍历结构>:
    <语句块>
- 从遍历结构中逐一提取元素，放在循环变量中
- 由保留字 for 和 in 组成，完成遍历所有元素后结束
- 每次循环，所获得元素放入循环变量，并执行一次语句块

#### 计数循环

```py
用法1：
for i in range(N):
    <语句块>
- 遍历由 range() 函数产生的数字序列，产生循环

用法2：
for i in range(M, N, K):
    <语句块>
- 遍历由 range()函数产生的数字序列，产生循环
- 这个指的是从M开始，到N之前的整数，K为步进

用法3：字符串遍历循环
for c in s:
    <语句块>
- s是字符串，遍历字符串每个字符，产生循环。
示例：
>>> for c in "Python123"
    print(c, end=",")
>>> P,y,t,h,o,n,1,2,3,

用法4：列表遍历循环
for item in ls:
    <语句块>
- ls是一个列表，遍历其每个元素，产生循环
示例：
>>> for item in [123, "py", 456]
        print(item, end=",")
>>> 123,py,456,

用法5：对文件进行遍历循环
for line in fi:
    <语句块>
- fi 是一个文件标识符，遍历其每行，产生循环

```

 for <循环遍历> in <遍历结构>：
    <语句块>
可以对以下内容进行循环：
- 计数循环（N次）
- 计数循环（特定次）
- 字符串遍历循环
- 列表遍历循环
- 文件遍历循环
- 。。。。。。


### 无限循环
由条件控制的循环运行方式

while <条件>:
    <语句块>
- 反复执行语句块，直到条件不满足时结束
ctrl + c 组合键 退出当前执行的程序

### 循环控制保留字
break 和 continue
- break 跳出并结束但钱整个循环，执行循环后的语句
- continue 结束当次循环，继续执行后续次数循环
- break 和 continue 可以与 for 和 while 循环搭配使用

```py
continue示例：
>>> for c in "PYTHON":
    if c == "T":
        continue        #如果是break,输出结果将只有PY
    print(c, end="")
>>> PYHON
```

```py
>>> s = "PYTHON"
>>> while s != "" :
        for c in s :
            print(c, end="")
        s = s[:-1]
>>> PYTHONPYTHOPYTHPYTPYP
```
- break 保留字，仅跳出最内层（仅跳出1层）的循环，外层循环依然有效

### 循环的高级用法
循环与else
- 当循环没有被break语句退出时，执行else语句块
- else语句块作为“正常”完成循环的奖励
- 这里else的用法与异常处理中else用法相似

```py
循环与slse示例：
>>> for c in "PYTHON"
        if c == "T":
            continue            #这里如果是break，else部分将不会被执行
        print(c, end="")
    else:
        print("正常退出")
>>> PYTHON正常退出
```

## 4.4 模块3：random库的使用

random库是使用随机数的python标准库

- 伪随机数：采用梅森旋转算法生成的（伪）随机序列中元素
- random库主要用于生成随机数
- 使用random库： import random

**random库包含两类函数，常用共8个** 

- 基本随机数函数：seed(),random()
- 扩展随机数函数：randint(),getrandbits(),uniform(),randrange(),choice(),shuffle()

### 基本随机数函数
随机数种子 → 梅森旋转算法 → 产生随机序列 
只要种子相同，产生的随机序列就是相同的。

| 函数 | 描述 |
|:----:|:----:|
| seed(a=None) | 初始化给定的随机数种子，默认为当前系统时间<br>>>> random.seed(10) #产生种子10对应的序列 |
| random() | 生成一个[0.0, 1.0)之间的随机小数<br>>>> random.random()<br>0.5714025946899135 |

给种子的时候（种子只需要给一次）后面就会产生随机数，如果不给种子，默认使用的是精确到微秒的时间来作为种子产生的随机数

所以如果程序需要复现的时候，就需要给种子了。

### 扩展随机数函数

| 函数 | 描述 |
|:----:|:----:|
| randint(a,b) | 生成一个[a, b]之间的整数<br>>>> random.randint(10, 100) <br>64 |
| randrange(m, n[, k]) | 生成一个[m, n)之间以k为步长的随机整数<br>>>> random.randrange(10, 100, 10) <br>80 |
| getrandbits(k) | 生成一个k比特长的随机整数<br>>>> random.getrandbits(16)<br>37885 |
| uniform(a, b) | 生成一个[a, b]之间的随机小数<br>>>> random.uniform(10, 100) <br> 13.096321648808136 |
| choice(seq) | 从序列seq中随机选择一个元素<br>>>> random.choice([1, 2, 3, 4, 5, 6, 7, 8, 9]) <br> 8 |
| shuffle(seq) | 将序列seq中元素随机排列，返回打乱后的序列<br>>>> s= [1, 2, 3, 4, 5, 6, 7, 8, 9];random.shuffle(s);print(s)<br> [3, 5, 8, 9, 6, 1, 2, 7, 4] |

**如果我们在python程序中，非要将几行代码打印在一行中，那么中间用*;* 间隔开来** 
**在实际的代码编写中，最好还是一行代码独占一行，因为这样的可读性更好** 

### 随机数函数的使用
- 需要掌握的能
    - 能够利用随机数种子产生“确定”伪随机数
    - 能够产生随机整数
    - 能够对序列类型进行随机操作

## 4.5 实例6：圆周率的计算

圆周率的计算方法：
1.科学家给出的计算公式
2.蒙特卡罗方法计算圆周率

**公式计算方法** 

```py
#!/usr/bin/python
# -*- coding: UTF-8 -*-

# Filename : 圆周率的计算
# Author by : hare
# Time : 2019.10.22

pi = 0
N = 100
for k in range(N):
    pi += 1 / pow(16, k) * ( \
        4 / (8 * k + 1) - 2 / (8 * k + 4) - \
        1 / (8 * k + 5) - 1 / (8 * k + 6))
print("圆周率值是：{}".format(pi))
```

**蒙特卡罗方法** 

```py
#!/usr/bin/python
# -*- condig: UTF-8 -*-

# FileName : 蒙特卡罗方法求圆的面积
# Author by : hare
# Time : 2019.10.22

from random import random
from time import perf_counter
DARTS = 1000 * 1000
hits = 0.0
start = perf_counter()
for i in range(1, DARTS + 1):
    x, y = random(), random()
    dist = pow(x ** 2 + y ** 2, 0.5)
    if dist <= 1.0:
        hits = hits + 1
pi = 4 * (hits/DARTS)
print("圆周率的值是：{}".format(pi))
print("运行时间是：{:.5f}s".format(perf_counter()-start))
```



