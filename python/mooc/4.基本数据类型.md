# 基本数据类型

## 数字类型及操作

### 整数类型
与数学中整数的概念一直
- 可正可负，没有取值范围限制
- pow（x，y）函数：计算x的y次方

**4种进制表示形式**
- 十进制：1010,99，,217
- 二进制：以0b或0B开头：0b010，,0B101
- 八进制：以0o或0O开头：0o123，,0O456
- 十六进制：以0x或0X开头：0x9a，-0X89

### 浮点类型
与数学中实数的概念一致
- 带有小数点及小数的数字
- 浮点数取值范围和小数精度都存在限制，但常规计算可忽略
- 取值范围数量级约-10^308至10^308，精度数量级10^-16

**浮点数运算存在不确定尾数，不是bug**（例如：0.1+0.2）

0.1 —— 53位二进制表示小数部分，约10^-16(可以无限接近，但并不是，因为十进制和二进制存在不对等关系）

```py
>>> 0.1 + 0.2 == 0.3
False

>>> round(0.1 + 0.2,1) == 0.3
True
```

**round(x,d)函数**
- 对x四舍五入，d时小数截取位数。
- 浮点数间运算及比较用round()函数辅助
- 不确定尾数一般发生在10^-16左右，round()十分有效

**科学计数法表示**

- 使用字母e或E作为幂的符号，以10为基数，格式如下：  
    `<a>e<b>     表示a*10^b`
- 例如：4.3e-3 值为0.0043  
9.6E5值为960000.0

### 复数

在众多编程语言中只有python提供复数。  
与数学中复数的概念一致

如果x^2=-1,那么x的值是什么？  
&ensp;&ensp;    定义j=根号下（-1），以此为基础，构建数学体系  
&ensp;&ensp;    a+bj被称为复数，其中，a是实部，b是虚部

z = 1.23e-4+5.6e89j  
&ensp;&ensp;  实部：z.real 获得实部  
&ensp;&ensp;  虚部：z.imag 获得虚部  

### 数值运算操作符

+、-、\*、/、//、%、\*\* :分别为加、减、乘、除（得小数）、地板除（舍去余数）、取余运算、幂运算

**二元操作符的增强赋值形式**回头再存把。

### 数字类型的关系
类型间可进行混合运算，生成结果为“最宽”类型  
 三种类型存在一种逐渐“扩展”或“变宽”的关系：  
    整数 -> 浮点数 -> 复数  
 例如：整数+浮点数=浮点数

### 数值运算函数

一些以函数形式提供的数值运算功能

| 函数及使用 | 描述 |
|:----:|:----:|
| abs(x) | 绝对值，x的绝对值<br>abs(-10.01)结果为10.01 |
| divmod(x,y) | 商余，(x//y,x%y),同时输出商和余数<br>divmod(10,3)结果为（3，1） |
| pow(x,y[,z]) | 幂余，(x\*\*y)%z,[...]表示参数z可省略<br>pow(3,pow(3,99),10000)结果为4587 |
| round(x[,d]) | 四舍五入，d时保留小数位，默认值为0<br>round(-10.123,2)结果为-10.12 |
| max(x_1,x_2,...,x_n) | 最大值，返回这几个数中的最大值，n不限<br>max(1,9,5,4,3)结果为9 |
| min(x1,x2,...,xn) | 最小值，返回这几个数中的最小值，n不限<br>min(1,9,2,5)结果为1 |
| int(x) | 将x变成整数，舍弃小数部分<br>int(123.45)结果为123；int("123")结果为123 |
| float(x) | 将x变成浮点数，增加小数部分<br>float(12)结果为12.0；float("1.23")结果为1.23 |
| complex(x) | 将x变成复数，增加虚数部分<br>complex(4)结果为4+0j |



## 实例3：天天向上的力量

基本问题：持续的价值
- 一年365天，每天进步1%，累计进步多少呢？
- 一年365天，每天退步1%，累计退步多少呢？
- 一年365天，工作日的力量是多少呢？

- GRIT:perseverance and passion for long-term goals
- GRIT,坚毅，对长期目标的持续激情一级持久耐力
- GRIT是获得成功最重要的因素之一，牢记天天向上的力量

第四个案例需要重新梳理一下，太晚了，有点累，休息了



## 字符串类型及操作

### 字符串类型的表示

由0个或多个字符组成的有序字符序列
- 字符串由一对单引号或一对双引号表示
- 字符串是字符的有序序列，可以对其中的一个字符进行索引

字符串有两类共4种表示方式
- 单引号
- 双引号
- 三单引号
- 三双引号

字符串切片

使用[M:N:K]根据步长对字符串切片（M开始，N结束（不包含N），K步长）  
[::-1]把字符串逆序

字符串的特殊字符  
转义符\
- 转义符表达特定字符的本意


### 字符串操作符

| 操作符及使用 | 描述 |
|:----:|:----:|
| x + y | 连接两个字符串 |
| n \* x | 或 x \* n 复制n次字符串x |
| x in s | 如果x时s的子串，返回True，否则返回False |


### 字符串处理函数

一些以函数形式提供的字符串处理功能  
（在python中无论英文字符、汉子、数字都算是一个字符，即他们的长度是相同的）  
(eval函数和str函数是一对函数，一个变成python可运行的（去掉引号）一个是变成字符串）  

| 函数及使用 | 描述 |
|:----:|:----:|
| len(x) | 长度，返回字符串x的长度<br>len("一二三456")结果为6 |
| str(x) | 任意类型x所对应的字符串形式<br>str(1.23)结果为"1.23" str([1,2])结果为"[1,2]" |
| hex(x)或oct(x) | 整数x的十六进制或八进制小写形式字符串<br>hex(425)结果为"0x1a9" oct(425)结果为"0o651" |
| chr(u) | u为Unicode编码，返回其对应的字符 |
| ord(x) | x为字符，返回其对应的Unicode编码 |

Unicode编码：python3中字符串的编码方式。  

- 统一字符编码，即覆盖几乎所有字符的编码方式。
- 从0到1114111(0x10FFFF）空间，每个编码对应一个字符
- Python字符串中每个字符都是Unicode编码字符

```py
>>> "1 + 1 = 2 " + chr(10004)
'1 + 1 = 2 对号‘
金牛字符的Unicode编码是9801
```

在python中例如：`print(chr(9800 + i), end="")`这里如果end=空表示输出不换行。

--------

### 字符串处理方法

"方法"在编程中是一个专有名词

- “方法”特指`<a>.<b>()`风格中函数`<b>()`
- 方法本身也是函数，但与`<a>`有关，`<a>.<b>()`风格使用
- 字符串及变量也是`<a>`,也存在一些方法

a.b编程风格，事实上是面向对象编程的一种风格。其中a是对象，b是某一个对象能够提供的功能我们叫方法.  
客观讲，方法是面向对象编程的专有名词。

**8个字符串常用方法**,需要全部掌握  

一些以方法形式提供的字符串处理功能

| 方法及使用 | 描述 |
|:----:|:----:|
| str.lower() 或 str.upper() | 返回字符串的副本，全部字符小写/大写<br>"AbCdEfGh".lower()结果为"abcdefgh" |
| str.split(sep=None) | 返回一个列表，由str根据sep被分隔的部分组成<br>"A,B,C".split(",")结果为['A','B','C'] |
| str.count(sub) | 返回子串sub在str中出现的次数<br>"an apple a day",count("a")结果为4 |
| str.replace(old, new) | 返回字符串str副本，所有old子串被替换为new<br>"python".replace("n","n123.io")结果为"python123.io" |
| str.center(width[,fillchar]) | 字符串str根据宽度width居中，fillchar可选<br>"python".center(20,"=")结果为'=======python=======' |
| str.strip(chars) | 从str中去掉在其中左侧和右侧chars中列出的字符<br>"= python= ".strip(" =np")结果为"ytho" |
| str.join(iter) | 在iter变量除最后元素外每个元素后增加一个str<br>",".join("12345")结果为"1,2,3,4,5" #主要用于字符串分隔等 |


### 字符串类型的格式化

格式化是对字符串进行格式化表达的方式

- 字符串格式化使用.format()方法，用法如下：  
    `<模板字符串>.format(<逗号分隔的参数>)`
- .format()方法需要和`{}`槽配合使用

例如：`"{1}是{0}开始学习{2}编程的".format("今天", "我", "python"`这里注意排序的问题，python默认排序是0,1,2...,但是我们可以调整顺序。

槽内部对格式化的配置方法  
{<参数序号> : <格式控制标记>}

在槽的内部除了**参数序号**之外，我们可用用引导符号`:`来引导格式控制标记。

python提供了6中格式控制标记

| 控制标记 | 作用 |
|:----:|:----:|
| <填充> | 用于填充的单个字符 |
| <对齐> | < 左对齐<br>> 右对齐<br>^ 居中对齐 |
| <宽度> | 槽设定的输出宽度 |
| <,> | 数字的千位分隔符 |
| <.精度> | 浮点数小数精度 或 <br>字符串最大输出长度 |
| <类型> | 整数类型 b, c, d, o, x, X<br>浮点数类型 e, E, f, % |

**前面三个可以看做一组，后面三个可以看做一组**

```py
>>> "{0:=^20}.format("PYTHON")
'=======PYTHON======='
# 槽中`:`后面先写填充；在写对齐方式；再写宽度

# 默认情况下无填充，左对齐；指定填充的时候默认填充空格。例如：
>>> "{0:10}.format("python")
'python    '
```

后面一组主要是对数字的控制

```py
# 千位分隔符;`.2`两位精度；`f`浮点数类型
>>> "{0:,.2f}.format(12345.6789)
'12,345.68'

>>> "{0:b},{0:c},{0:d},{0:0},{0:x},{0:X}".format(425)
'110101001, ,425,651,1a9,1A9'
# b：二进制
# c：字符形式（Unicode编码形式，这里打不出来所以空喽）
# d：十进制
# o：八进制
# x：十六进制
# X：大写的十六进制

>>> "{0:e},{0:E},{0:f},{0:%}".format(3.14)
'3.140000e+00,3.140000E+00,3.140000,314.000000%'
# e：小e科学计数法表示
# E：大E科学计数法表示
# f：普通浮点数形式表示
# %：百分号形式表示
```

**python编程需要注意的是，所有标点符号都得是英文半角符号**

--------

## 模块2：time库的使用

### time库基本介绍

time库是python中处理时间的标准库

- 计算机时间的表达
- 提供获取系统时间并格式化输出功能
- 提供系统级精确计时功能，用于程序性能分析

time库的使用方式：

```py
import time

time.<b>
```

### 时间获取

时间获取：time()  ctime()  gmtime()

| 函数 | 描述 |
|:----:|:----:|
| time() | 获取当前时间戳，即计算机内部时间值，浮点数<br>>>>time.time()<br>1516939876.6022282 |
| ctime() | 获取当前时间并以易读的方式表示，返回字符串<br>>>> time.ctime()<br>'Fri Jan 26 12:11:16 2018' |
| gmtime() | 获取当前时间，表示为计算机可以处理的时间格式<br>time.gmtime() |

时间戳：表示从1970年1月1日0:00开始到当前时刻开始的，以秒为单位的数值。

gmtime是其他程序可以利用的时间格式。

### 时间格式化

将时间以合理的方式展示出来

- 格式化：类似字符串格式化，需要有展示模板
- 展示模板由特定的格式化控制符组成
- strftime()方法

时间格式化：strftime()  strptime()

| 函数 | 描述 |
|:----:|:----:|
| strftime(tpl, ts) | tpl是格式化模板字符串，用来定义输出效果，ts是计算机内部时间类型变量 <br>>>>t = time.gmtime()<br>>>>time.strftime("%Y-%m-%d %H:%M:%S", t)<br>'2018-01-26 12:55:20' |
| strptime(str, tpl) | str是字符串形式的时间值<br>tpl是格式化模板字符串，用来定义输出效果<br>>>>timeStr = '2019-01-26 12:55:20'<br>>>>time.strptime(timeStr, "%Y-%m-%d %H:%M:%S") |

--------


| 格式化字符串 | 日期/时间说明 | 值范围和实例 |
|:----:|:----:|:----:|
| %Y | 年份 | 0000~9999，例如：1900 |
| %m | 月份 | 01~12，例如：10 |
| %B | 月份名称 | January~December，例如：April |
| %b | 月份名称缩写 | Jan~Dec，例如：Apr |
| %d | 日期 | 01~31，例如：25 |
| %A | 星期 | Monday～Sunday，例如：Wednesday |
| %a | 星期缩写 | Mon～Sun，例如：Wed |
| %H | 小时（24h制） | 00～23，例如：12 |
| %I | 小时（12h制） | 01～12，例如：7 |
| %p | 上/下午 | AM,PM，例如：PM |
| %M | 分钟 | 00～59，例如：26 |
| %s | 秒 | 00～59，例如：26 |

--------


### 程序计时应用

程序计时：sleep() &ensp;&ensp; perf_counter()

程序计时应用广泛

- 程序计时指测量起止动作所经历的过程
- 测量时间：perf_counter()
- 产生时间：sleep()

| 函数 | 描述 |
|:----:|:----:|
| perf_counter() | 返回一个CPU级别的精确时间计数值，单位为秒<br>由于这个计数值起点不确定，连续调用差值才有意义<br>>>>start = time.perf_counter()<br>318.66599499718114<br>>>>end = time.perf_counter()<br>314.3905185375658<br>>>>end - start<br>22.724523540384666 |
| sleep(s) | s拟休眠的时间，单位是秒，可以是浮点数<br>>>>def wait():<br>    time.sleep(3.3)<br>>>>wait() #程序将等待3.3秒后再退出 |

- 单独调用一次perf_counter()并没有用，调用两次，用第二次减去第一次就是时间差


## 实例4：文本进度条

- 案例1：
 采用字符串方式打印可以动态变化的文本进度条
 进度条需要能在一行中逐渐变化

```py
#!/usr/bin/python
# -*- coding: UTF-8 -*-

# filename : TextBar
# Author by : hare
# time : 2019.10.16

import time
scale = 10
print("-------执行开始-------")
for i in range(scale + 1):
    a = '*' * i
    b = '_' * (scale - i)
    c = (i / scale) * 100
    print("{:^3.0f}%[{}->{}]".format(c,a,b))
    time.sleep(0.1)
print("-------执行结束-------")
```

- 案例2：
刷新的本质是：用后打印的字符覆盖之前的字符  
不能换行：print()需要被控制  
要能回退：打印后光标退回到之前的位置 `\r`  

```py
#!/usr/bin/python
# -*- coding: UTF-8 -*-

# FileName : TextproBarV2.py
# Author by : hare
# Time : 2019.10.16

import time
for i in range(101):
    print("\r{:3}%".format(i), end="") #这里是print的一个方法，end=""(如果想要在输出的内容后面增加信息，就添加在""中，如果不向输出换行，""中为空即可（因为print默认输出换行）
# 如果在IDLE中测试可能会有部分问题，因为他们屏蔽了`\r`命令
```

```py
#!/usr/bin/python
# -*- coding: UTF-8 -*-

# FileName : TextproBarV3.py
# Author by : hare
# Time : 2019.10.16

import time
scale = 50
print("执行开始".center(scale//2, "-"))
start = time.perf_counter()
for i in range(scale + 1):
    a = '*' * i
    b = '.' * (scale - i)
    c = (i / scale) * 100
    dur = time.perf_counter() - start
    print("\r{:^3.0f}%[{}->{}]{:.2f}s".format(c, a, b, dur), end="")
    time.sleep(0.1)
print("执行结束".center(scale//2, "-"))
```

### 举一反三
进度条扩展

- 在任何运行时间需要较长的过程中增加进度条
- 在任何希望提高用户体验的应用中增加进度条
- 进度条是人机交互的纽带之一

卡耐基梅陇大学实验证明：先慢后快，用户体验最好

文本进度条的不同设计函数

| 设计名称 | 趋势 | 设计函数 |
|:----:|:----:|:----:|
| Linear | Constant | f(x) = x |
| Early Pause | Speeds up | f(x) = x+(1-sin(x*π*2+π/2)/-8 |
| Late Pause | Slows down | f(x) = x+(1-sin(x*π*2+π/2)/8 |
| Slow Wavy | Constant | f(x) = x+sin(x*π*5)/20 |
| Fast Wavy | Constant | f(x) = x+sin(x*π*20)/80 |
| Power | Speeds up | f(x) = (x+(1-x)*0.03)**2 |
| Inverse Power | Slows down | f(x) = 1+(1-x)**1.5*-1 |
| Fast Power | Speeds up | f(x) = (x+(1-x)/2)**8 |
| Inverse Fast Power | Slows down | f(x) = 1+(1-x)**3*-1 |




