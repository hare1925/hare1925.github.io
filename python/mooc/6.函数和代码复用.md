# 第五章 函数和代码复用

**方法论** 
- Python基本代码抽象即函数的使用方法

**实践能力** 
- 学会编写带有函数并复用代码的程序

## 5.1 函数的定义与使用

- 函数的理解与定义
- 函数的使用及调用过程
- 函数的参数传递
- 函数的返回值
- 局部变量和全局变量
- lambda函数

### 函数的定义
- 函数是一段具有特定功能的、可重用的语句组
- 函数是一种功能的抽象、一般函数表达特定功能
- 两个作用：**降低变成难度** 和**代码复用** 

**函数是一段代码的表示** 

```py
def <函数名>(<参数(0个或多个)>):
    <函数体>
    return <返回值>
```

*案例* :计算n！

```py
def fact(n):
    s = 1
    for i in range(1, n+1):
        s *= i
    return s
```

**函数的定义** 需要注意的地方
- 函数定义时，所指定的参数是一种**占位符** 
- 函数定义后，如果不经过**调用** ，不会被执行
- 函数定义时，参数是输入、函数体是处理、结果是输出（IPO）

*简单理解* : 函数是IPO的一种实现，函数也是一段完整代码的一种封装

### 函数的使用及调用过程

**调用是运行函数代码的方式** 

`fact(10)` 函数的调用

- 调用时要给出实际参数
- 实际参数替换定义中参数
- 函数调用后得到返回值

### 参数个数

**函数可以有参数，也可以没有，但必须保留括号** 

### 可选参数传递

```py
def <函数名>(<非可选参数>,<可选参数>):
    <函数体>
    return <返回值>
```

**可选参数传递示例** 

```py
def fact(n, m=1):       # 设置m的默认值为 1
    s = 1
    for i in range(1, n+1):
        s *= i
    return s//m     # 定义返回值为s整除m

# 结果为：

>>> fact(10)        # 无可选参数
3628800

>>> fact(10, 5)     # 有可选参数
725760
```

### 可变参数传递

函数定义时可以设计可变数量参数，即不确定参数总数量

```py
def <函数名>(<参数>, *b ):      # 这里的b可以是一个自定义的变量
    <函数体>
    return <返回值>
```

**可变参数传递示例** 

```py
def fact(n, *b):
    s = 1
    for i in range(1, n+1):
        s *= i
    for item in b:
        s *= item
    return s

# 结果为：

>>> fact(10, 3)
10886400

>>> fact(10, 3, 5, 8)   #这里指的是可以同时给出多个可变参数，定逐一打印他们的结果
43546000
```

### 参数传递的两种方式

**位置传递** 

```py
>>> fact(10, 5)
```

**名称传递**  
指定形式参数m和n的值来定义  

```py
>>> fact(m=5, n=10)
```

### 函数的返回值

**函数可以返回0个或多个结果**  

- return保留字用来传递返回值
- 函数可以有返回值，也可以没有，可以有return，也可以没有
- return可以传递0个返回值，也可以传递任意多个返回值

**示例**  

```py
def fact(n, m=1):
    s = 1
    for i in range(1, n+1):
        s *= i
    return s//m, n, m

# 调用返回结果为:元组类型

>>> fact(10, 5)
(725760, 10, 5) # 这里是元组类型

# 调用返回给指定的值

>>> a, b, c = fact(10, 5)
>>> print(a, b, c)
725760 10 5
```

### 局部变量和全局变量

- **全局变量** 整个程序使用的变量
- **局部变量** 函数内部使用的变量

#### 局部变量和全局变量的使用规则

**规则1** :局部变量和全局变量是不同的变量
    * 局部变量是函数内部的占位符，与全局变量可能重名但不同
    * 函数运算结束后，局部变量被释放
    * 可以使用*global* 保留字在函数内部使用全局变量

**示例** 局部变量和全局变量不同  

```py
n, s = 10, 100
def fact(n):
    s = 1   #这里的s是局部变量，与全局变量s不同
    for i in range(1, n+1):
        s *= i
    return s    #这里返回的是局部变量的s，是3628800
print(fact(n), s)   #这里的是全局变量 s的值是100

# 所以，结果如下：

>>> 3628800 100     #因为打印的是全局变量的s
```

**示例** 在函数中使用*global* ，即函数中使用全局变量

```py
n, s = 10, 100
def fact(n):
    golbal s    # fact()函数中使用golbal保留字，声明此处s是全局变量
    for i in range(1, n+1):
        s *= i
    return s    # 此处s指的是全局变量s
print(fact(n), s)   # 此处局部变量s被函数修改
```

**规则2** :局部变量为组合数据类型且未创建，等同于全局变量  

```py
ls = ["F", "f"]     # 通过使用[]真实创建了一个全局变量列表ls
def func(a):
    ls.append(a)    #此处ls是列表类型，未真实创建则等同于全局变量
    return
func("c")   #全局变量ls被修改
print(ls)

#运行结果为
>>> ['F', 'f', 'c']
```

**如果我们在一个函数定义中使用了一个组合数据类型** 例如上面例子，ls没有在函数内部创建，它本身名字又等同于一个全局变量，那么这段函数就是在处理这个全局变量

```py
ls = ["F", "f"]     #通过使用[]真实创建了一个全局变量列表ls
def func(a):
    ls = []     # 此处ls是列表类型，真实创建（ls是局部变量）
    return
func("C")  #局部变量ls被修改
print(ls)

>>> ["F", "f"]      #结果为全局变量的值
```

**如果一个组合数据类型，在函数中被真实创建了，那么它就是这个函数的局部变量，在函数运行之后，这个变量就会被释放了，它就不存在了，它跟外部的全局变量ls是不同的变量** 

**组合数据类型，在python中实际是由指针来体现的，所以函数中如果没有真实创建数据类型，它使用的变量是使用的指针，而指针指的是外部的全局变量，所以修改这个指针对应的内容就修改了全局变量** 


#### 使用规则
- 基本数据类型，无论是否重名，局部变量与全局变量不同
- 可以通过global保留字在函数内部声明全局变量
- 组合数据类型，如果局部变量未被真实创建，则是全局变量

### lambda函数

#### lambda函数返回函数名作为结果

- lambda函数是一种匿名函数，即没有名字的函数
- 使用lambda保留字定义，函数名是返回结果
- lambda函数用于定义简单的、能够在一行内表示的函数

`<函数名> = lambda <参数>:<表达式>` 
等价于
```py
def <函数名>(<参数>):
    <函数体>
    return <返回值>
```

不同的是，lambda后面只能使用表达式，而不能使用函数体

```py
>>> f = lambda x, y : x + y
>>> f(10, 15)
25

>>> f = lambda : "lambda函数"
>>> print(f())
lambda函数
```

**一般在写代码的时候定义函数，哪怕这个函数代码仅有一行，也建议使用def和return这种方式去定义，而不建议使用lambda函数**  

#### 谨慎使用lambda函数
- lambda函数主要作用一些特定函数或方法的参数
- lambda函数有一些固定使用方式，建议逐步掌握
- 一般情况，建议使用def定义的普通函数



## 5.2 实例7：七段数码管绘制

### 七段数码管绘制

- 需求： 用程序绘制七段数码管，似乎很有趣
- 该怎么做呢？

之前学过turtle绘图体系 ——》 七段数码管绘制

### 基本思路

- 步骤1：绘制单个数字对应的数码管
- 步骤2：获得一串数字，绘制对应的数码管
- 步骤3：获得当前系统时间，绘制对应的数码管

#### 步骤1：绘制单个数码管

- 七段数码管由7个基本线条组成
- 七段数码管可以有固定顺序
- 不同数字显示不同的线条


## 5.3 代码复用与函数递归

## 5.4 模块4：PyInstaller库的使用

## 5.5 实例8：科赫雪花小包裹


