# 第五章 函数和代码复用

**方法论** 
- Python基本代码抽象即函数的使用方法

**实践能力** 
- 学会编写带有函数并复用代码的程序

## 5.1 函数的定义与使用

- 函数的理解与定义
- 函数的使用及调用过程
- 函数的参数传递
- 函数的返回值
- 局部变量和全局变量
- lambda函数

### 函数的定义
- 函数是一段具有特定功能的、可重用的语句组
- 函数是一种功能的抽象、一般函数表达特定功能
- 两个作用：**降低变成难度** 和**代码复用** 

**函数是一段代码的表示** 

```py
def <函数名>(<参数(0个或多个)>):
    <函数体>
    return <返回值>
```

*案例* :计算n！

```py
def fact(n):
    s = 1
    for i in range(1, n+1):
        s *= i
    return s
```

**函数的定义** 需要注意的地方
- 函数定义时，所指定的参数是一种**占位符** 
- 函数定义后，如果不经过**调用** ，不会被执行
- 函数定义时，参数是输入、函数体是处理、结果是输出（IPO）

*简单理解* : 函数是IPO的一种实现，函数也是一段完整代码的一种封装

### 函数的使用及调用过程

**调用是运行函数代码的方式** 

`fact(10)` 函数的调用

- 调用时要给出实际参数
- 实际参数替换定义中参数
- 函数调用后得到返回值

### 参数个数

**函数可以有参数，也可以没有，但必须保留括号** 

### 可选参数传递

```py
def <函数名>(<非可选参数>,<可选参数>):
    <函数体>
    return <返回值>
```

**可选参数传递示例** 

```py
def fact(n, m=1):       # 设置m的默认值为 1
    s = 1
    for i in range(1, n+1):
        s *= i
    return s//m     # 定义返回值为s整除m

# 结果为：

>>> fact(10)        # 无可选参数
3628800

>>> fact(10, 5)     # 有可选参数
725760
```

### 可变参数传递

函数定义时可以设计可变数量参数，即不确定参数总数量

```py
def <函数名>(<参数>, *b ):      # 这里的b可以是一个自定义的变量
    <函数体>
    return <返回值>
```

**可变参数传递示例** 

```py
def fact(n, *b):
    s = 1
    for i in range(1, n+1):
        s *= i
    for item in b:
        s *= item
    return s

# 结果为：

>>> fact(10, 3)
10886400

>>> fact(10, 3, 5, 8)   #这里指的是可以同时给出多个可变参数，定逐一打印他们的结果
43546000
```

### 参数传递的两种方式

**位置传递** 

```py
>>> fact(10, 5)
```

**名称传递**  
指定形式参数m和n的值来定义  

```py
>>> fact(m=5, n=10)
```

### 函数的返回值

**函数可以返回0个或多个结果**  

- return保留字用来传递返回值
- 函数可以有返回值，也可以没有，可以有return，也可以没有
- return可以传递0个返回值，也可以传递任意多个返回值

**示例**  

```py
def fact(n, m=1):
    s = 1
    for i in range(1, n+1):
        s *= i
    return s//m, n, m

# 调用返回结果为:元组类型

>>> fact(10, 5)
(725760, 10, 5) # 这里是元组类型

# 调用返回给指定的值

>>> a, b, c = fact(10, 5)
>>> print(a, b, c)
725760 10 5
```

### 局部变量和全局变量

- **全局变量** 整个程序使用的变量
- **局部变量** 函数内部使用的变量

#### 局部变量和全局变量的使用规则

**规则1** :局部变量和全局变量是不同的变量  

    * 局部变量是函数内部的占位符，与全局变量可能重名但不同  
    * 函数运算结束后，局部变量被释放  
    * 可以使用*global* 保留字在函数内部使用全局变量  

**示例** 局部变量和全局变量不同  

```py
n, s = 10, 100
def fact(n):
    s = 1   #这里的s是局部变量，与全局变量s不同
    for i in range(1, n+1):
        s *= i
    return s    #这里返回的是局部变量的s，是3628800
print(fact(n), s)   #这里的是全局变量 s的值是100

# 所以，结果如下：

>>> 3628800 100     #因为打印的是全局变量的s
```

**示例** 在函数中使用*global* ，即函数中使用全局变量

```py
n, s = 10, 100
def fact(n):
    golbal s    # fact()函数中使用golbal保留字，声明此处s是全局变量
    for i in range(1, n+1):
        s *= i
    return s    # 此处s指的是全局变量s
print(fact(n), s)   # 此处局部变量s被函数修改
```

**规则2** :局部变量为组合数据类型且未创建，等同于全局变量  

```py
ls = ["F", "f"]     # 通过使用[]真实创建了一个全局变量列表ls
def func(a):
    ls.append(a)    #此处ls是列表类型，未真实创建则等同于全局变量
    return
func("c")   #全局变量ls被修改
print(ls)

#运行结果为
>>> ['F', 'f', 'c']
```

**如果我们在一个函数定义中使用了一个组合数据类型** 例如上面例子，ls没有在函数内部创建，它本身名字又等同于一个全局变量，那么这段函数就是在处理这个全局变量

```py
ls = ["F", "f"]     #通过使用[]真实创建了一个全局变量列表ls
def func(a):
    ls = []     # 此处ls是列表类型，真实创建（ls是局部变量）
    return
func("C")  #局部变量ls被修改
print(ls)

>>> ["F", "f"]      #结果为全局变量的值
```

**如果一个组合数据类型，在函数中被真实创建了，那么它就是这个函数的局部变量，在函数运行之后，这个变量就会被释放了，它就不存在了，它跟外部的全局变量ls是不同的变量** 

**组合数据类型，在python中实际是由指针来体现的，所以函数中如果没有真实创建数据类型，它使用的变量是使用的指针，而指针指的是外部的全局变量，所以修改这个指针对应的内容就修改了全局变量** 


#### 使用规则
- 基本数据类型，无论是否重名，局部变量与全局变量不同
- 可以通过global保留字在函数内部声明全局变量
- 组合数据类型，如果局部变量未被真实创建，则是全局变量

### lambda函数

#### lambda函数返回函数名作为结果

- lambda函数是一种匿名函数，即没有名字的函数
- 使用lambda保留字定义，函数名是返回结果
- lambda函数用于定义简单的、能够在一行内表示的函数

`<函数名> = lambda <参数>:<表达式>` 

等价于

```py
def <函数名>(<参数>):
    <函数体>
    return <返回值>
```

不同的是，lambda后面只能使用表达式，而不能使用函数体

```py
>>> f = lambda x, y : x + y
>>> f(10, 15)
25

>>> f = lambda : "lambda函数"
>>> print(f())
lambda函数
```

**一般在写代码的时候定义函数，哪怕这个函数代码仅有一行，也建议使用def和return这种方式去定义，而不建议使用lambda函数**  

#### 谨慎使用lambda函数
- lambda函数主要作用一些特定函数或方法的参数
- lambda函数有一些固定使用方式，建议逐步掌握
- 一般情况，建议使用def定义的普通函数



## 5.2 实例7：七段数码管绘制

### 七段数码管绘制

- 需求： 用程序绘制七段数码管，似乎很有趣
- 该怎么做呢？

之前学过turtle绘图体系 ——》 七段数码管绘制

### 基本思路

- 步骤1：绘制单个数字对应的数码管
- 步骤2：获得一串数字，绘制对应的数码管
- 步骤3：获得当前系统时间，绘制对应的数码管

#### 步骤1：绘制单个数码管

- 七段数码管由7个基本线条组成
- 七段数码管可以有固定顺序
- 不同数字显示不同的线条

#### 步骤2：获取一段数字，绘制多个数码管

#### 获得系统时间，绘制漂亮的数码管

- 使用time库获得系统当前时间
- 增加年月日标记
- 年月日颜色不同

#### 举一反三

**理解方法思维** 

- 模块化思维：确定模块借口，封装功能
- 规则化思维：抽象过程为规则，计算机自动执行
- 化繁为简：将大功能变为小功能组合，分而治之

**应用问题的扩展** 

- 绘制带小数点的七段数码管
- 带刷新的时间倒计时效果
- 绘制高级的数码管

## 5.3 代码复用与函数递归

- 代码复用与模块化设计
- 函数递归的理解
- 函数递归的调用过程
- 函数递归实例解析

### 代码复用

#### 把代码当成资源进行抽象

- 代码资源化：程序代码是一种用来表达计算的“资源”
- 代码抽象化：使用函数等方法对代码赋予更高级别的定义
- 代码复用：同一份代码在需要时可以被重复使用

#### 函数 和 对象 是代码复用的两种主要形式

**函数** 将代码命名在代码层面建立了初步抽象
**对象** 属性和方法 `<a>.<b> 和 <a>.<b>()` 在函数之上再次组织进行抽象

#### 模块化设计

**分而治之** 

- 通过函数或对象封装将程序划分为模块及模块间的表达
- 具体包括：主程序、子程序和子程序间关系
- 分而治之：一种分而治之、分成抽象、体系化的设计思想

**紧耦合 松耦合** 
- 紧耦合：两个部分之间交流很多，无法独立存在
- 松耦合：两个部分之间交流较少，可以独立存在
- 模块诶不紧耦合、模块之间松耦合

#### 递归的定义

函数定义中调用自身的方式

**两个挂件特征** 

- 链条：计算过程中存在递归链条
- 基例：存在一个或多个不需要再次递归的基例

**类似数学归纳法** 

- 数学归纳法
- 证明当n取第一个值n0时命题成立
- 假设当nk时命题成立，证明当n=nk+1时命题也成立
- 递归是数学归纳法思维的编程体现

#### 函数递归的调用过程

汉诺塔

- 函数+分支结构
- 递归链条
- 递归基例

```py
# 汉诺塔实例-理解汉诺塔链条
count = 0
def hanoi(n, stc, dst, mid):
    global count
    if n == 1 :
        print("{}:{}->{}".format(1, src, dst))
        count += 1
    else:
        hanoi(n-1, src, mid, dst)
        print("{}:{}->{}".format(n, src, dst))
        count += 1
        hanoi(n-1, mid, dst, src)

hanoi(3, "A", "C", "B")
print(count)
```

这个单元需要重新学习。

## 5.4 模块4：PyInstaller库的使用

### PyInstaller库概述

**将`.py` 源代码转换成无需源代码的可执行文件** 

- windows下可以通过pyinstaller变成.exe文件

### PyInstaller库是第三方库

- 官方网址：http://www.pyinstaller.org
- 第三方库：使用前需要额外安装
- 安装第三方库需要使用pip工具
- 在命令行直接： pip install pyinstaller 就好了

### PyInstaller的使用

（cmd命令行）pyinstaller -F <文件名.py>
完成后后会生成3个文件
1. __pycache__（可以删除）
2. build （可以删除）
3. dist （此目录下会有.exe文件）

#### pyinstaller常用参数

| 参数 | 描述 |
|:----:|:----:|
| -h | 查看帮助 |
| --clean | 清理打包过程中的临时文件 |
| -D，--onedir | 默认值，生成dist文件夹 |
| -F，--onefile | 在dist文件夹中只生成独立的打包文件 |
| -i<图标文件名.ico> | 指定打包程序使用的图标(icom)文件 |

`pyinstaller -i curve.ico -F SevenDigitsDrawV2.py` curve是图标文件名


## 5.5 实例8：科赫雪花小包裹

### 高大上的分形几何

- 分形几何是一种迭代的几何图形，广泛存在与自然界中

### 科赫曲线，也叫科赫雪花

### 用python绘制科赫曲线

**一条直线，三分之一直线，三分之一60度再转回来，再三分之一直线** 

- 递归思想：函数+分支
- 递归链条：线段的组合
- 递归基例：初识线段

### 举一反三

**绘制条件的扩展** 

- 修改分形几何绘制阶数
- 修改科赫曲线的基本定义及旋转角度
- 修改绘制科赫雪花的基础框架图形


**分形几何千千万**  

- 康托尔集，歇尔宾斯基三角形，门格海绵
- 龙形曲线，空间填充曲线，科赫曲线
- 函数递归的深入应用。。。






