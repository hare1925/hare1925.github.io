# 模块

如果你从python解释器退出并在此进入，之前的定义（函数和变量）都会丢失。因此，如果你想编写一个稍微长些的程序，最好使用文本编辑器为解释器准备输入并将该文件作为输入运行。这被称为编写**脚本**。随着编写程序变得越来越长，你或许会想把它拆分称为几个文件，以方便维护。你亦或想在不同的程序中使用一个便捷的函数，而不必把这个函数复制到每一个程序中去。

为支持这些，python有一种方法可以把定义放在一个文件里，并在脚本或解释器的交互式实例中使用他们。这样的文件被称为**模块**：模块中的定义可以 引导 到其它模块或者 主 模块（你在顶级和计算器模式下执行的脚本中可以访问的变量合集）。

模块是一个包含python定义和语句的文件。文件名就是模块名后跟文件后缀`.py`。
在一个模块内部，模块名（作为一个字符串）可以通过全局变量`__name__`的值获得。例如，使用你最喜爱的文本编辑器在当前目录下创建一个名为`fibo.py`的文件，文件中含有以下内容：

```py
# Fibonacci numbers module

def fib(n):    # write Fibonacci series up to n
    a, b = 0, 1
    while a < n:
        print(a, end=' ')
        a, b = b, a+b
    print()

def fib2(n):   # return Fibonacci series up to n
    result = []
    a, b = 0, 1
    while a < n:
        result.append(a)
        a, b = b, a+b
    return result
```

现在进入python解释器，并用以下命令导入该模块：

`>>> import fibo`

在当前的符号表中，这并不会直接进入到定义在 `fibo` 函数内的名称；它只是进入到模块名 `fibo` 中。你可以用模块名访问这些函数：

```py
>>> fibo.fib(1000)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
>>> fibo.fib2(100)
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
>>> fibo.__name__
'fibo'
```

如果你想经常使用某个函数，你可以把它赋值给一个局部变量:

```py
>>> fib = fibo.fib
>>> fib(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
```

---

## 6.1 更多有关模块的信息

模块可以包含可执行的语句以及函数定义。这些语句用于初始化模块。它们仅在模块 第一次 在 import 语句中被导入时才执行。 1 (当文件被当作脚本运行时，它们也会执行。)

每个模块都有它自己的私有符号表，该表用作模块中定义的所有函数的全局符号表。因此，模块的作者可以在模块内使用全局变量，而不必担心与用户的全局变量发生意外冲突。另一方面，如果你知道自己在做什么，则可以用跟访问模块内的函数的同样标记方法，去访问一个模块的全局变量，modname.itemname。

模块可以导入其它模块。习惯上但不要求把所有 import 语句放在模块（或脚本）的开头。被导入的模块名存放在调入模块的全局符号表中。

import 语句有一个变体，它可以把名字从一个被调模块内直接导入到现模块的符号表里。例如:

```py
>>> from fibo import fib, fib2
>>> fib(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
```

这并不会把被调模块名引入到局部变量表里（因此在这个例子里，fibo 是未被定义的）。

还有一个变体甚至可以导入模块内定义的所有名称:


```py
>>> from fibo import *
>>> fib(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
```

这会调入所有非以下划线（\_）开头的名称。 在多数情况下，Python程序员都不会使用这个功能，因为它在解释器中引入了一组未知的名称，而它们很可能会覆盖一些你已经定义过的东西。

注意通常情况下从一个模块或者包内调入 \* 的做法是不太被接受的， 因为这通常会导致代码的可读性很差。不过，在交互式编译器中为了节省打字可以这么用。

如果模块名称之后带有 as，则跟在 as 之后的名称将直接绑定到所导入的模块。


```py
>>> import fibo as fib
>>> fib.fib(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
```

这会和 import fibo 方式一样有效地调入模块， 唯一的区别是它以 fib 的名称存在的。

It can also be used when utilising from with similar effects:

```py
>>> from fibo import fib as fibonacci
>>> fibonacci(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
```

```


注解

出于效率的考虑，每个模块在每个解释器会话中只被导入一次。因此，如果你更改了你的模块，则必须重新启动解释器， 或者，如果它只是一个要交互式地测试的模块，请使用 importlib.reload()，例如 import importlib; importlib.reload(modulename)。
```

---

### 6.1.1 以脚本的方式执行模块
























