# 5 数据结构

## 5.1 列表的更多特性

列表数据类型还有很多的方法。这里时列表对象方法的情单：

| 方法 | 解释 | 备注 |
|:----:|:----:|:----:|
| list.append(x) | 在列表的末尾添加一个元素。 | 相当于 a[len(a):] = [x] |
| list.extend(iterable) | 使用可迭代对象中的所有元素来扩展列表。 | 相当于 a[len(a):] = iterable |
| list.insert(i,x) | 在给定的位置插入一个元素。 | 第一个参数时要插入的元素的索引，所以 a.insert(0, x) 插入列表头， a.insert(len(a), x) 等同于 a.append(x) |
| list.remove(x) | 移除列表中第一个值为x的元素 | 如果没有这样的元素，则抛出 ValueError 异常 |
| list.pop([i]) | 删除列表中给定位置的元素并返回它 | 如果没有给定位置， a.php() 将会删除并返回列表中的最后一个元素。（方法签名中i两边的方括号表示这个参数是可选的，而不是要你输入方括号。（python参考库中经常看到这种表示方法）|
| list.chear() | 删除列表中所有的元素 | 相当于 del a[:] |
| list.index(x[,start[,end]]) | 返回里列表中第一个值为x的元素的从零开始的索引 | 如果没有这样的元素将会抛出 ValueError 异常<br> 可选参数 start 和 end 是切片符号，用于将搜索限制为列表的特定子序列。返回的索引是相对于整个序列的开始计算的，而不是 start 参数 |
| list.count(x) | 返回元素x在列表中出现的次数 ||
| list.sort(key=None,reverse=False) | 对里诶博爱中元素进行排序（参数可用于自定义排序，解释参见 sorted() ) |
| list.reverse() | 反转列表中的元素 ||
| list.copy() | 返回列表的一个浅拷贝 | 相当于 a[:] |


列表方法示例：

```py
>>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana']
>>> fruits.count('apple')
2
>>> fruits.count('tangerine')
0
>>> fruits.index('banana')
3
>>> fruits.index('banana', 4)  # Find next banana starting a position 4
6
>>> fruits.reverse()
>>> fruits
['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']
>>> fruits.append('grape')
>>> fruits
['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']
>>> fruits.sort()
>>> fruits
['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']
>>> fruits.pop()
'pear'
```

你可能已经注意到，像 insert ，remove 或者 sort 方法，只修改列表，没有打印出返回值——它们返回默认值 None 。1 这是Python中所有可变数据结构的设计原则。

### 5.1.1 列表作为栈使用

列表方法使得列表作为堆栈非常容易，最后一个插入，最先取出（”后进先出")。
- 要添加一个元素到堆栈的顶端，使用 append()
- 要从堆栈顶部取出一个元素，使用 pop()
- 不用指定索引。

```py
>>> stack = [3, 4, 5]
>>> stack.append(6)
>>> stack.append(7)
>>> stack
[3, 4, 5, 6, 7]
>>> stack.pop()
7
>>> stack
[3, 4, 5, 6]
>>> stack.pop()
6
>>> stack.pop()
5
>>> stack
[3, 4]
```

### 5.1.2 列表最为队列使用

列表也可以作为队列，其中先添加的元素被最先取出（“先进先出”）；然而列表用作这个目的相当低效率。因为在列表的末尾添加和弹出一个元素非常快，但是在列表的开头插入或弹出元素却很慢（因为所有的其他元素都必须移动一位）。

若要实现以个队列， collections.deque 被设计用于快速地从两端操作。例如

```py
>>> from collections import deque
>>> queue = deque(["Eric", "John", "Michael"])
>>> queue.append("Terry")           # Terry arrives
>>> queue.append("Graham")          # Graham arrives
>>> queue.popleft()                 # The first to arrive now leaves
'Eric'
>>> queue.popleft()                 # The second to arrive now leaves
'John'
>>> queue                           # Remaining queue in order of arrival
deque(['Michael', 'Terry', 'Graham'])
```

### 5.1.3 列表推导式

列表推导式提供了一个更简单的创建列表的方法。常见的用法是把某种操作应用于徐磊或可迭代对象的每个元素上，然后使用其结果来创建列表，或通过满足某些特定条件来创建子序列。

例如，假设我们想创建一个平方列表，like this：

```py
>>> squares = []
>>> for x in range(10):
...     squares.append(x**2)
...
>>> squares
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

注意这里创建（或被重写）的名为x的变量在for循环后仍然存在。我们可以计算平方列表的值而不会产生任何副作用

`squares = list(map(lanbda x: x**2,range(10)))`

或者，等价于

`squares = [x**2 for x in range(10)]`

上面这种写法更加简洁。


**列表推导式的结构**
是由一堆方括号所包含的以下内容：
- 一个表达式；
- 后跟一个for字句
- 然后是零个或多个for或if子句
其结果将是一个新列表，由对表达式依据后面的for和if子句的内容进行求职计算而得出。

举例来说，以下列表推导式会将两个列表中不相等的元素组合起来：

```py
>>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
```

它等价于

```py
>>> combs = []
>>> for x in [1,2,3]:
...     for y in [3,1,4]:
...         if x != y:
...             combs.append((x, y))
...
>>> combs
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
```

**注意**在上面两个代码片段中，for和if的顺序是相同的。

表达式是一个元组（例如上面的（x, y)),那么就必须加上括号

```py
>>> vec = [-4, -2, 0, 2, 4]
>>> # create a new list with the values doubled
>>> [x*2 for x in vec]
[-8, -4, 0, 4, 8]
>>> # filter the list to exclude negative numbers
>>> [x for x in vec if x >= 0]
[0, 2, 4]
>>> # apply a function to all the elements
>>> [abs(x) for x in vec]
[4, 2, 0, 2, 4]
>>> # call a method on each element
>>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']
>>> [weapon.strip() for weapon in freshfruit]
['banana', 'loganberry', 'passion fruit']
>>> # create a list of 2-tuples like (number, square)
>>> [(x, x**2) for x in range(6)]
[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]
>>> # the tuple must be parenthesized, otherwise an error is raised
>>> [x, x**2 for x in range(6)]
  File "<stdin>", line 1, in <module>
    [x, x**2 for x in range(6)]
               ^
SyntaxError: invalid syntax
>>> # flatten a list using a listcomp with two 'for'
>>> vec = [[1,2,3], [4,5,6], [7,8,9]]
>>> [num for elem in vec for num in elem]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

列表推导式可以使用负责的表达式和嵌套函数

```py
>>> from math import pi
>>> [str(round(pi, i)) for i in range(1, 6)]
['3.1', '3.14', '3.142', '3.1416', '3.14159']
```

### 5.1.4 嵌套的列表推导式













